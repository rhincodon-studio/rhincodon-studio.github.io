<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="rss.xsl"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Rhincodon Studio Blog</title>
        <link>https://rhincodon.studio/en/blog</link>
        <description>Rhincodon Studio Blog</description>
        <lastBuildDate>Sat, 29 Nov 2025 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[使用 MDX 打造互動式文件]]></title>
            <link>https://rhincodon.studio/en/blog/docusaurus-mdx-demo</link>
            <guid>https://rhincodon.studio/en/blog/docusaurus-mdx-demo</guid>
            <pubDate>Sat, 29 Nov 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[為什麼選擇 MDX？]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="為什麼選擇-mdx">為什麼選擇 MDX？<a href="https://rhincodon.studio/en/blog/docusaurus-mdx-demo#%E7%82%BA%E4%BB%80%E9%BA%BC%E9%81%B8%E6%93%87-mdx" class="hash-link" aria-label="Direct link to 為什麼選擇 MDX？" title="Direct link to 為什麼選擇 MDX？" translate="no">​</a></h2>
<p>當你需要說明重點提示、互動範例或分頁程式碼等更豐富的敘事方式時，可以在 Markdown 中混用 React 元件；而一般文字仍維持純 Markdown，兼顧易寫與彈性。</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</div><div class="admonitionContent_BuS1"><p>讓 MDX 區塊維持精簡（建議 40 行內），並替所有媒體提供描述性的 alt 文字，方便後續翻譯與在地化。</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="分頁內容範例">分頁內容範例<a href="https://rhincodon.studio/en/blog/docusaurus-mdx-demo#%E5%88%86%E9%A0%81%E5%85%A7%E5%AE%B9%E7%AF%84%E4%BE%8B" class="hash-link" aria-label="Direct link to 分頁內容範例" title="Direct link to 分頁內容範例" translate="no">​</a></h2>
<div class="theme-tabs-container tabs-container tabList__CuJ"><ul role="tablist" aria-orientation="horizontal" class="tabs"><li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_LNqP tabs__item--active">CLI 檢查清單</li><li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_LNqP">TypeScript 筆記</li><li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_LNqP">Example</li></ul><div class="margin-top--md"><div role="tabpanel" class="tabItem_Ymn6"><ol>
<li>下載最新範本並執行 <code>npm install</code>。</li>
<li>透過 <code>npm run start</code> 在本機確認頁面載入正常。</li>
<li>將遇到的錯誤與重現步驟加到 issue 描述中。</li>
</ol></div><div role="tabpanel" class="tabItem_Ymn6" hidden=""><ul>
<li>先在 Markdown 定義所有可翻譯字串，再用 props 傳入 React 元件。</li>
<li>為 MDX 互動元件設計 <code>Props</code> 型別，方便其他作者複用。</li>
<li>若多篇文章都用到相同邏輯，可移到 <code>@site/src/components/</code> 匯入。</li>
</ul></div><div role="tabpanel" class="tabItem_Ymn6" hidden=""><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;Tabs groupId="language"&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;TabItem value="checklist" label="CLI 檢查清單"&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1. 下載最新範本並執行 `npm install`。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        2. 透過 `npm run start` 在本機確認頁面載入正常。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3. 將遇到的錯誤與重現步驟加到 issue 描述中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/TabItem&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;TabItem value="notes" label="TypeScript 筆記"&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 先在 Markdown 定義所有可翻譯字串，再用 props 傳入 React 元件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 為 MDX 互動元件設計 `Props` 型別，方便其他作者複用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 若多篇文章都用到相同邏輯，可移到 `@site/src/components/` 匯入。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/TabItem&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/Tabs&gt;</span><br></span></code></pre></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="可用的主題元件">可用的主題元件<a href="https://rhincodon.studio/en/blog/docusaurus-mdx-demo#%E5%8F%AF%E7%94%A8%E7%9A%84%E4%B8%BB%E9%A1%8C%E5%85%83%E4%BB%B6" class="hash-link" aria-label="Direct link to 可用的主題元件" title="Direct link to 可用的主題元件" translate="no">​</a></h2>
<ul>
<li><a href="https://docusaurus.io/docs/markdown-features/tabs" target="_blank" rel="noopener noreferrer"><code>Tabs</code> 與 <code>TabItem</code></a> 能在同一區塊切換語言或平台</li>
<li><a href="https://docusaurus.io/docs/markdown-features/code-blocks#mdx-component" target="_blank" rel="noopener noreferrer"><code>CodeBlock</code></a> 方便加上區塊標題或切成 live editor</li>
<li><a href="https://docusaurus.io/docs/markdown-features/admonitions" target="_blank" rel="noopener noreferrer"><code>Admonition</code></a> 與 <a href="https://docusaurus.io/docs/markdown-features/details#mdx" target="_blank" rel="noopener noreferrer"><code>Details</code></a> 可凸顯警示或折疊補充說明</li>
</ul>]]></content:encoded>
            <category>Docusaurus</category>
            <category>mdx</category>
            <category>docs</category>
        </item>
        <item>
            <title><![CDATA[前端常見測試框架比較：Vitest、Jest、Karma、Jasmine]]></title>
            <link>https://rhincodon.studio/en/blog/frontend-test-runner-comparison</link>
            <guid>https://rhincodon.studio/en/blog/frontend-test-runner-comparison</guid>
            <pubDate>Sat, 29 Nov 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[以實務需求角度比較四個常見前端測試框架，協助你選擇適合的工具鏈。]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="為什麼要比較測試框架">為什麼要比較測試框架？<a href="https://rhincodon.studio/en/blog/frontend-test-runner-comparison#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E6%AF%94%E8%BC%83%E6%B8%AC%E8%A9%A6%E6%A1%86%E6%9E%B6" class="hash-link" aria-label="Direct link to 為什麼要比較測試框架？" title="Direct link to 為什麼要比較測試框架？" translate="no">​</a></h2>
<p>團隊在規劃測試策略時，往往需要兼顧開發體驗、既有 CI/CD 工具與瀏覽器支援度。這篇文章整理 Vitest、Jest、Karma 與 Jasmine 的定位差異，讓你快速判斷哪一套最符合專案需求。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="核心差異一覽">核心差異一覽<a href="https://rhincodon.studio/en/blog/frontend-test-runner-comparison#%E6%A0%B8%E5%BF%83%E5%B7%AE%E7%95%B0%E4%B8%80%E8%A6%BD" class="hash-link" aria-label="Direct link to 核心差異一覽" title="Direct link to 核心差異一覽" translate="no">​</a></h2>
<table><thead><tr><th>框架</th><th>核心定位</th><th>執行環境</th><th>亮點</th><th>適合情境</th></tr></thead><tbody><tr><td>Vitest</td><td>Vite 生態系預設測試框架</td><td>Node.js（可透過 Vitest UI 觸發瀏覽器）</td><td>與 Vite 設定共享、原生 ESM、啟動極快</td><td>使用 Vite/Vue/React 並追求極速回饋的專案</td></tr><tr><td>Jest</td><td>Facebook 推出的通用測試框架</td><td>Node.js、JSDOM</td><td>Snapshot 測試、模組模擬、社群資源豐富</td><td>需要穩定 API、搭配 React/React Native 的團隊</td></tr><tr><td>Karma</td><td>利用真實瀏覽器跑測試的 Test Runner</td><td>真實瀏覽器（Chrome、Firefox 等）</td><td>可整合 Webpack/SystemJS，適合舊專案</td><td>必須驗證瀏覽器 API 或需要大量整合測試</td></tr><tr><td>Jasmine</td><td>早期 BDD 風格測試框架</td><td>瀏覽器或 Node.js</td><td>零依賴、語法簡潔</td><td>嵌入式或低依賴場景、AngularJS 舊專案</td></tr></tbody></table>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_BuS1"><p>若專案使用 Angular 14+ 並維持 CLI 預設，通常會同時搭配 Karma + Jasmine；若改用 Vite 驅動專案，就可考慮 Vitest 取代 Jest/Karma。</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="快速評估指南">快速評估指南<a href="https://rhincodon.studio/en/blog/frontend-test-runner-comparison#%E5%BF%AB%E9%80%9F%E8%A9%95%E4%BC%B0%E6%8C%87%E5%8D%97" class="hash-link" aria-label="Direct link to 快速評估指南" title="Direct link to 快速評估指南" translate="no">​</a></h2>
<ol>
<li><strong>優先考慮開發體驗</strong>：需要快速回饋與原生 ESM？Vitest 幾乎零設定，且能共用 Vite alias。</li>
<li><strong>看重生態與教學資源</strong>：Jest 在社群套件、文件、CI 範例上仍最完整，適合多語言團隊。</li>
<li><strong>要測到真實瀏覽器</strong>：Karma 擅長打開多個瀏覽器並收集覆蓋率，對 Web API、Legacy 專案仍有價值。</li>
<li><strong>依賴最少、可嵌入</strong>：Jasmine 沒有外部 runner，但可輕鬆嵌入自訂腳本或 Karma、Protractor 等工具。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="實務選型建議">實務選型建議<a href="https://rhincodon.studio/en/blog/frontend-test-runner-comparison#%E5%AF%A6%E5%8B%99%E9%81%B8%E5%9E%8B%E5%BB%BA%E8%AD%B0" class="hash-link" aria-label="Direct link to 實務選型建議" title="Direct link to 實務選型建議" translate="no">​</a></h2>
<ul>
<li><strong>Vite + Vue/React 新專案</strong>：直接選 Vitest，搭配 <code>vitest run --coverage</code> 即可整合 CI。</li>
<li><strong>Next.js 或 React Native</strong>：Jest 有現成的環境模擬與 Snapshot 工具，且能與 Testing Library 無縫整合。</li>
<li><strong>長期維護的 AngularJS/Angular 專案</strong>：保留 Karma + Jasmine，逐步以 Web Test Runner 或 Vitest 替換即可。</li>
<li><strong>需要真實瀏覽器 E2E 但不想導入 Cypress/Playwright</strong>：Karma + Jasmine 仍是輕量選擇，可與 WebDriver 共享設定。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="總結">總結<a href="https://rhincodon.studio/en/blog/frontend-test-runner-comparison#%E7%B8%BD%E7%B5%90" class="hash-link" aria-label="Direct link to 總結" title="Direct link to 總結" translate="no">​</a></h2>
<p>選擇測試框架時請先盤點：</p>
<ul>
<li>Build 工具（Vite、Webpack、Angular CLI）</li>
<li>目標執行環境（Node、瀏覽器、Hybrid）</li>
<li>期望維護成本（社群範例、既有腳本）</li>
</ul>
<p>只要釐清上述條件，就能在 Vitest、Jest、Karma、Jasmine 之間做出更符合團隊節奏的決策。</p>]]></content:encoded>
            <category>testing</category>
            <category>vitest</category>
            <category>jest</category>
            <category>karma</category>
            <category>jasmine</category>
        </item>
        <item>
            <title><![CDATA[在 WebStorm 中整合 Codex 工作流程]]></title>
            <link>https://rhincodon.studio/en/blog/webstorm-codex-setup</link>
            <guid>https://rhincodon.studio/en/blog/webstorm-codex-setup</guid>
            <pubDate>Sat, 29 Nov 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[教你如何在 WebStorm 透過 Codex CLI 快速完成指令、腳本與部落格撰寫工作。]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="什麼是-codex">什麼是 Codex？<a href="https://rhincodon.studio/en/blog/webstorm-codex-setup#%E4%BB%80%E9%BA%BC%E6%98%AF-codex" class="hash-link" aria-label="Direct link to 什麼是 Codex？" title="Direct link to 什麼是 Codex？" translate="no">​</a></h2>
<p><a href="https://openai.com/zh-Hant/codex/" target="_blank" rel="noopener noreferrer">Codex</a> 是 OpenAI 提供的程式碼生成助手，能解讀自然語言並輸出程式碼、指令或文字。本文示範如何在 WebStorm 中透過 Codex CLI 建立一個以對話驅動的工作流程。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="為什麼要在-ide-中使用-codex">為什麼要在 IDE 中使用 Codex？<a href="https://rhincodon.studio/en/blog/webstorm-codex-setup#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%9C%A8-ide-%E4%B8%AD%E4%BD%BF%E7%94%A8-codex" class="hash-link" aria-label="Direct link to 為什麼要在 IDE 中使用 Codex？" title="Direct link to 為什麼要在 IDE 中使用 Codex？" translate="no">​</a></h2>
<p>WebStorm 已經提供完善的 TypeScript/React 體驗，但若再結合 Codex CLI，就能以對話方式生成模板、整理文件或批次修改檔案。這讓日常的重複性動作（例如建立部落格、填寫 front matter、插入多國語系內容）都能在同一個 IDE 視窗完成。</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</div><div class="admonitionContent_BuS1"><p>Codex 維持在同一個版本最容易除錯，建議專案以 <code>package.json</code> script 管理，例如 <code>"codex": "npx codex"</code>，避免團隊成員版本不一致。</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="安裝與初始設定">安裝與初始設定<a href="https://rhincodon.studio/en/blog/webstorm-codex-setup#%E5%AE%89%E8%A3%9D%E8%88%87%E5%88%9D%E5%A7%8B%E8%A8%AD%E5%AE%9A" class="hash-link" aria-label="Direct link to 安裝與初始設定" title="Direct link to 安裝與初始設定" translate="no">​</a></h2>
<ol>
<li>先在系統層級安裝 Codex CLI：<!-- -->
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">npm install -g @openai/codex-cli</span><br></span></code></pre></div></div>
</li>
<li>在專案根目錄建立或更新 <code>.context/</code>（例如 <code>docusaurus-guidelines.md</code>），把前置規範寫入，並於每次執行前指示 Codex 先閱讀。</li>
<li>若想用固定指令呼叫 Codex，可在 <code>package.json</code> 中加入腳本（底層仍呼叫全域 <code>codex</code> 或 <code>npx codex</code>）：<!-- -->
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token property" style="color:#36acaa">"scripts"</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">"codex"</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"codex"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">"codex:plan"</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"codex --plan"</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="在-webstorm-綁定-codex-指令">在 WebStorm 綁定 Codex 指令<a href="https://rhincodon.studio/en/blog/webstorm-codex-setup#%E5%9C%A8-webstorm-%E7%B6%81%E5%AE%9A-codex-%E6%8C%87%E4%BB%A4" class="hash-link" aria-label="Direct link to 在 WebStorm 綁定 Codex 指令" title="Direct link to 在 WebStorm 綁定 Codex 指令" translate="no">​</a></h2>
<ol>
<li>打開 <strong>Run/Debug Configurations</strong>，新增 <strong>npm</strong> 或 <strong>Shell Script</strong>。</li>
<li>指定 Script 為 <code>codex</code>，Working directory 指向專案根目錄。</li>
<li>勾選 <strong>Activate tool window</strong> 讓結果出現在 Run 面板，方便複製貼上。</li>
<li>若想要快速輸入指令，可在 <strong>Keymap → Plugins → External Tools</strong> 為 <code>codex</code> 配快捷鍵，例如 <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>;</kbd>。</li>
</ol>
<p>透過以上設定，就能在任意檔案按一次快捷鍵，立即呼叫 Codex 完成編輯或回覆。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="常見工作流程">常見工作流程<a href="https://rhincodon.studio/en/blog/webstorm-codex-setup#%E5%B8%B8%E8%A6%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" class="hash-link" aria-label="Direct link to 常見工作流程" title="Direct link to 常見工作流程" translate="no">​</a></h2>
<ul>
<li><strong>撰寫部落格</strong>：執行 <code>npm run codex -- "create blog on webstorm"</code>，Codex 會依照 <code>.context</code> 中的規範與當天日期產生檔案，再由你在 WebStorm 內調整。</li>
<li><strong>批次重構</strong>：在終端切換到目標資料夾，讓 Codex 讀取檔案後輸入具體需求，例如「將所有 fetch 換成 axios」。</li>
<li><strong>Docs QA</strong>：透過 <code>codex --plan</code> 整理多步驟修改，把輸出貼進 <code>.mdx</code> 檔案，並利用 WebStorm Diff 介面快速檢查。做法是先在終端執行 <code>npm run codex:plan -- \"&lt;需求描述&gt;\"</code>，依序執行計畫並將 Codex 產生的內容貼回對應文件，最後用 Diff 檢查每一步是否符合預期。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="疑難排解">疑難排解<a href="https://rhincodon.studio/en/blog/webstorm-codex-setup#%E7%96%91%E9%9B%A3%E6%8E%92%E8%A7%A3" class="hash-link" aria-label="Direct link to 疑難排解" title="Direct link to 疑難排解" translate="no">​</a></h2>
<ul>
<li><strong>終端無法解析 codex 指令</strong>：確認 WebStorm 使用的 Node 版本與系統一致，或在設定中的 Shell path 改成 <code>/bin/zsh -l</code>。</li>
<li><strong>CLI 無法寫入檔案</strong>：在 Codex 命令前加入 <code>CODEx_SANDBOX=workspace-write</code>（依專案需求）或檢查 repository 權限。</li>
<li><strong>輸出語言錯誤</strong>：把「預設使用繁體中文」寫在 <code>.context</code>，並提醒 Codex 每次編輯前重新閱讀該檔案。</li>
</ul>
<p>善用這套流程，就能在 WebStorm 中持續保持專注，同時享受到 Codex 的自動化與解題效率。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="其他可搭配的工具">其他可搭配的工具<a href="https://rhincodon.studio/en/blog/webstorm-codex-setup#%E5%85%B6%E4%BB%96%E5%8F%AF%E6%90%AD%E9%85%8D%E7%9A%84%E5%B7%A5%E5%85%B7" class="hash-link" aria-label="Direct link to 其他可搭配的工具" title="Direct link to 其他可搭配的工具" translate="no">​</a></h2>
<ul>
<li><a href="https://platform.claude.com/" target="_blank" rel="noopener noreferrer">Claude</a>：在需要長篇推理或分析文件時可當作補充顧問。</li>
<li><a href="https://kiro.dev/" target="_blank" rel="noopener noreferrer">Kiro</a>：主打工程自動化，可接續 Codex 的結果進行端到端測試或部署。</li>
</ul>]]></content:encoded>
            <category>codex</category>
            <category>webstorm</category>
            <category>automation</category>
        </item>
        <item>
            <title><![CDATA[將多個 Nx Apps 部署到同一個 Nginx 下]]></title>
            <link>https://rhincodon.studio/en/blog/2025/11/28</link>
            <guid>https://rhincodon.studio/en/blog/2025/11/28</guid>
            <pubDate>Fri, 28 Nov 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[教你如何將 Nx monorepo 內多個 Angular / Web apps 透過 Nginx 部署到同一個域名或不同路徑下。]]></description>
            <content:encoded><![CDATA[<p>Nx monorepo 內通常包含多個前端或後端應用，例如：</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apps/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  app1/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  app2/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  app3/</span><br></span></code></pre></div></div>
<p>透過 Nx build 後，你會得到：</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dist/apps/app1/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dist/apps/app2/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dist/apps/app3/</span><br></span></code></pre></div></div>
<p>本篇文章將教你如何把這些 apps 同時部署到同一個 Nginx 下，並使用不同路徑或不同子網域。</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="方法-a使用不同路徑最常見">方法 A：使用不同路徑（最常見）<a href="https://rhincodon.studio/en/blog/2025/11/28#%E6%96%B9%E6%B3%95-a%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%91%E6%9C%80%E5%B8%B8%E8%A6%8B" class="hash-link" aria-label="Direct link to 方法 A：使用不同路徑（最常見）" title="Direct link to 方法 A：使用不同路徑（最常見）" translate="no">​</a></h2>
<p>例如：</p>
<ul>
<li><a href="https://example.com/app1" target="_blank" rel="noopener noreferrer">https://example.com/app1</a></li>
<li><a href="https://example.com/app2" target="_blank" rel="noopener noreferrer">https://example.com/app2</a></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nginx-設定">Nginx 設定<a href="https://rhincodon.studio/en/blog/2025/11/28#nginx-%E8%A8%AD%E5%AE%9A" class="hash-link" aria-label="Direct link to Nginx 設定" title="Direct link to Nginx 設定" translate="no">​</a></h3>
<div class="language-nginx codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-nginx codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 80;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  server_name example.com;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /app1/ {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alias /usr/share/nginx/html/app1/;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try_files $uri $uri/ /app1/index.html;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /app2/ {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alias /usr/share/nginx/html/app2/;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try_files $uri $uri/ /app2/index.html;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="angular--nx-build-指令">Angular / Nx Build 指令<a href="https://rhincodon.studio/en/blog/2025/11/28#angular--nx-build-%E6%8C%87%E4%BB%A4" class="hash-link" aria-label="Direct link to Angular / Nx Build 指令" title="Direct link to Angular / Nx Build 指令" translate="no">​</a></h3>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nx build app1 --configuration production --base-href=/app1/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nx build app2 --configuration production --base-href=/app2/</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="部署的資料夾結構">部署的資料夾結構<a href="https://rhincodon.studio/en/blog/2025/11/28#%E9%83%A8%E7%BD%B2%E7%9A%84%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B" class="hash-link" aria-label="Direct link to 部署的資料夾結構" title="Direct link to 部署的資料夾結構" translate="no">​</a></h3>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/usr/share/nginx/html/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  app1/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  app2/</span><br></span></code></pre></div></div>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="方法-b使用不同子網域">方法 B：使用不同子網域<a href="https://rhincodon.studio/en/blog/2025/11/28#%E6%96%B9%E6%B3%95-b%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E5%AD%90%E7%B6%B2%E5%9F%9F" class="hash-link" aria-label="Direct link to 方法 B：使用不同子網域" title="Direct link to 方法 B：使用不同子網域" translate="no">​</a></h2>
<p>例如：</p>
<ul>
<li><a href="https://app1.example.com/" target="_blank" rel="noopener noreferrer">https://app1.example.com</a></li>
<li><a href="https://app2.example.com/" target="_blank" rel="noopener noreferrer">https://app2.example.com</a></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nginx-設定-1">Nginx 設定<a href="https://rhincodon.studio/en/blog/2025/11/28#nginx-%E8%A8%AD%E5%AE%9A-1" class="hash-link" aria-label="Direct link to Nginx 設定" title="Direct link to Nginx 設定" translate="no">​</a></h3>
<div class="language-nginx codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-nginx codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  server_name app1.example.com;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  root /usr/share/nginx/html/app1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try_files $uri $uri/ /index.html;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  server_name app2.example.com;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  root /usr/share/nginx/html/app2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try_files $uri $uri/ /index.html;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="angular--nx-build-指令-1">Angular / Nx Build 指令<a href="https://rhincodon.studio/en/blog/2025/11/28#angular--nx-build-%E6%8C%87%E4%BB%A4-1" class="hash-link" aria-label="Direct link to Angular / Nx Build 指令" title="Direct link to Angular / Nx Build 指令" translate="no">​</a></h3>
<p>由於每個 app 直接掛在根目錄（/），<code>baseHref</code> 設為 <code>/</code> 即可：</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nx build app1 --configuration production --base-href=/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nx build app2 --configuration production --base-href=/</span><br></span></code></pre></div></div>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="方法-c透過-proxy-pass-導流到後端服務api--ssr--node--nodejs">方法 C：透過 Proxy Pass 導流到後端服務（API / SSR / Node / NodeJS）<a href="https://rhincodon.studio/en/blog/2025/11/28#%E6%96%B9%E6%B3%95-c%E9%80%8F%E9%81%8E-proxy-pass-%E5%B0%8E%E6%B5%81%E5%88%B0%E5%BE%8C%E7%AB%AF%E6%9C%8D%E5%8B%99api--ssr--node--nodejs" class="hash-link" aria-label="Direct link to 方法 C：透過 Proxy Pass 導流到後端服務（API / SSR / Node / NodeJS）" title="Direct link to 方法 C：透過 Proxy Pass 導流到後端服務（API / SSR / Node / NodeJS）" translate="no">​</a></h2>
<p>如果你的 Nx monorepo 中包含後端服務（例如 NodeJS API），你可以使用 <code>proxy_pass</code>：
讓 Nginx 將 <code>/api</code> 相關請求導向後端 server。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nginx-proxy-pass-設定範例">Nginx Proxy Pass 設定範例<a href="https://rhincodon.studio/en/blog/2025/11/28#nginx-proxy-pass-%E8%A8%AD%E5%AE%9A%E7%AF%84%E4%BE%8B" class="hash-link" aria-label="Direct link to Nginx Proxy Pass 設定範例" title="Direct link to Nginx Proxy Pass 設定範例" translate="no">​</a></h3>
<div class="language-nginx codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-nginx codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 80;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  server_name example.com;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # 前端 Angular App</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location / {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    root /usr/share/nginx/html/app1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try_files $uri $uri/ /index.html;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # API Proxy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /api/ {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_pass http://localhost:3333/; # Nx serve / NodeJS 的 API port</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_http_version 1.1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_set_header Upgrade $http_upgrade;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_set_header Connection 'upgrade';</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_set_header Host $host;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_cache_bypass $http_upgrade;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="常見-proxy-pass-場景">常見 Proxy Pass 場景<a href="https://rhincodon.studio/en/blog/2025/11/28#%E5%B8%B8%E8%A6%8B-proxy-pass-%E5%A0%B4%E6%99%AF" class="hash-link" aria-label="Direct link to 常見 Proxy Pass 場景" title="Direct link to 常見 Proxy Pass 場景" translate="no">​</a></h3>
<ol>
<li>
<p><strong>Nx + Angular 前端 + NodeJS API</strong></p>
<ul>
<li><code>/</code> → 前端</li>
<li><code>/api</code> → 後端（NodeJS）</li>
</ul>
</li>
<li>
<p><strong>多後端服務（微服務結構）</strong></p>
<ul>
<li><code>/auth</code> → Auth service</li>
<li><code>/order</code> → Order service</li>
<li><code>/payment</code> → Payment service</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nx--nodejs-服務常用指令">Nx + NodeJS 服務常用指令<a href="https://rhincodon.studio/en/blog/2025/11/28#nx--nodejs-%E6%9C%8D%E5%8B%99%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4" class="hash-link" aria-label="Direct link to Nx + NodeJS 服務常用指令" title="Direct link to Nx + NodeJS 服務常用指令" translate="no">​</a></h3>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nx serve api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nx build api</span><br></span></code></pre></div></div>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="常見問題faq">常見問題（FAQ）<a href="https://rhincodon.studio/en/blog/2025/11/28#%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8Cfaq" class="hash-link" aria-label="Direct link to 常見問題（FAQ）" title="Direct link to 常見問題（FAQ）" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="為什麼重新整理會出現-404">為什麼重新整理會出現 404？<a href="https://rhincodon.studio/en/blog/2025/11/28#%E7%82%BA%E4%BB%80%E9%BA%BC%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E6%9C%83%E5%87%BA%E7%8F%BE-404" class="hash-link" aria-label="Direct link to 為什麼重新整理會出現 404？" title="Direct link to 為什麼重新整理會出現 404？" translate="no">​</a></h3>
<p>SPA（如 Angular）本身沒有真正的路徑，因此 Nginx 需要設定：</p>
<div class="language-nginx codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-nginx codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">try_files $uri $uri/ /index.html;</span><br></span></code></pre></div></div>
<p>這會讓所有路徑回到 Angular 的 router 處理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="proxy-pass-無法連線">Proxy Pass 無法連線？<a href="https://rhincodon.studio/en/blog/2025/11/28#proxy-pass-%E7%84%A1%E6%B3%95%E9%80%A3%E7%B7%9A" class="hash-link" aria-label="Direct link to Proxy Pass 無法連線？" title="Direct link to Proxy Pass 無法連線？" translate="no">​</a></h3>
<p>檢查：</p>
<ul>
<li>後端 port 是否正確（如 <code>3333</code>）</li>
<li>後端是否允許來自 localhost 的 request</li>
<li>Nginx 有沒有加 <code>proxy_set_header Host $host</code></li>
<li>是否需要 HTTPS → HTTP 的 <code>proxy_redirect off;</code></li>
</ul>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="總結">總結<a href="https://rhincodon.studio/en/blog/2025/11/28#%E7%B8%BD%E7%B5%90" class="hash-link" aria-label="Direct link to 總結" title="Direct link to 總結" translate="no">​</a></h2>
<p>你可以透過三種方式把多個 Nx apps 與後端部署在同一個 Nginx：</p>
<ol>
<li><strong>不同路徑</strong>（最常見、單一 domain）</li>
<li><strong>不同子網域</strong>（乾淨、好管理）</li>
<li><strong>Proxy Pass 導後端 API</strong>（前後端整合最佳解）</li>
</ol>
<p>只要正確設定：</p>
<ul>
<li>Nginx alias/root</li>
<li>Angular baseHref</li>
<li>try_files</li>
<li>proxy_pass（如有後端 API）</li>
</ul>
<p>即可達成完整的 Nx monorepo 部署架構。</p>]]></content:encoded>
            <category>nx</category>
            <category>angular</category>
            <category>nginx</category>
            <category>deployment</category>
        </item>
        <item>
            <title><![CDATA[Nx App 拆分優勢與策略步驟]]></title>
            <link>https://rhincodon.studio/en/blog/nx-app-split-strategy</link>
            <guid>https://rhincodon.studio/en/blog/nx-app-split-strategy</guid>
            <pubDate>Thu, 27 Nov 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[以最安全的 Clone & Carve 策略，將單一 Angular Nx App 拆分為前台與後台兩個獨立應用，並可保留原有路由與逐步驗證。]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-背景說明">1. 背景說明<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#1-%E8%83%8C%E6%99%AF%E8%AA%AA%E6%98%8E" class="hash-link" aria-label="Direct link to 1. 背景說明" title="Direct link to 1. 背景說明" translate="no">​</a></h2>
<p>目前前端專案採用 Nx monorepo，原本僅有單一應用程式 <code>shopping-app</code>，同時承載：</p>
<ul>
<li>一般使用者（前台）功能</li>
<li>管理者／營運人員（後台）功能</li>
</ul>
<p>隨著功能擴充與角色複雜度提升，單一 App 逐漸出現以下問題：</p>
<ul>
<li>bundle 體積愈來愈大，首屏載入時間增加</li>
<li>測試與除錯範圍變廣，改一小段功能要驗證很多頁面</li>
<li>權限、導覽、UI 風格混雜在一起，維護成本高</li>
<li>部署策略無法細緻，例如：只想更新後台功能但仍須重建整個 App</li>
</ul>
<p>為解決上述問題，我們規劃將前端拆分為兩個獨立 App，並保留既有路由邏輯與使用者習慣。</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-拆成兩個-app-的優勢">2. 拆成兩個 App 的優勢<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#2-%E6%8B%86%E6%88%90%E5%85%A9%E5%80%8B-app-%E7%9A%84%E5%84%AA%E5%8B%A2" class="hash-link" aria-label="Direct link to 2. 拆成兩個 App 的優勢" title="Direct link to 2. 拆成兩個 App 的優勢" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-架構與責任分離">2.1 架構與責任分離<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#21-%E6%9E%B6%E6%A7%8B%E8%88%87%E8%B2%AC%E4%BB%BB%E5%88%86%E9%9B%A2" class="hash-link" aria-label="Direct link to 2.1 架構與責任分離" title="Direct link to 2.1 架構與責任分離" translate="no">​</a></h3>
<p>拆分後我們會有兩個應用：</p>
<ul>
<li><code>shopping-app</code>：前台，面向一般使用者</li>
<li><code>backoffice-app</code>：後台，面向管理者／營運人員</li>
</ul>
<p>優勢：</p>
<ul>
<li>前後台的路由、版型、權限可以完全分開設計</li>
<li>開發時不會被另一個角色的 UI 汙染</li>
<li>規格討論可以針對各自 App 進行，不互相牽扯</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-打包與建置時間優化">2.2 打包與建置時間優化<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#22-%E6%89%93%E5%8C%85%E8%88%87%E5%BB%BA%E7%BD%AE%E6%99%82%E9%96%93%E5%84%AA%E5%8C%96" class="hash-link" aria-label="Direct link to 2.2 打包與建置時間優化" title="Direct link to 2.2 打包與建置時間優化" translate="no">​</a></h3>
<p>在 Nx 下，拆分多個 App 可以搭配：</p>
<ul>
<li>incremental build（增量編譯）</li>
<li>affected:* 指令（只建置有受影響的專案）</li>
</ul>
<p>實際效果：</p>
<ul>
<li>只修改後台程式碼時，可僅建置 <code>backoffice-app</code></li>
<li>前台沒有變動就不需重新 build，CI 時間與成本下降</li>
<li>本地開發時可以只啟動自己關心的 App，啟動速度較快</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="23-bundle-大小與載入效能改善">2.3 bundle 大小與載入效能改善<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#23-bundle-%E5%A4%A7%E5%B0%8F%E8%88%87%E8%BC%89%E5%85%A5%E6%95%88%E8%83%BD%E6%94%B9%E5%96%84" class="hash-link" aria-label="Direct link to 2.3 bundle 大小與載入效能改善" title="Direct link to 2.3 bundle 大小與載入效能改善" translate="no">​</a></h3>
<ul>
<li>前台不再需要下載後台相關的頁面與元件</li>
<li>Admin 專用 UI / library 不會出現在前台 bundle 中</li>
<li>Lazy loading 策略可以更乾淨，依 App 設計懸掛不同的 chunk</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="24-權限與安全性清晰化">2.4 權限與安全性清晰化<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#24-%E6%AC%8A%E9%99%90%E8%88%87%E5%AE%89%E5%85%A8%E6%80%A7%E6%B8%85%E6%99%B0%E5%8C%96" class="hash-link" aria-label="Direct link to 2.4 權限與安全性清晰化" title="Direct link to 2.4 權限與安全性清晰化" translate="no">​</a></h3>
<ul>
<li>後台 App 可以在 routing 層、部署層各自設計權限控管</li>
<li>反向代理（nginx / gateway）可針對不同 path/domain 做額外保護</li>
<li>不讓 admin 專用的頁面隨前台一起被發佈</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="25-部署與版本獨立">2.5 部署與版本獨立<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#25-%E9%83%A8%E7%BD%B2%E8%88%87%E7%89%88%E6%9C%AC%E7%8D%A8%E7%AB%8B" class="hash-link" aria-label="Direct link to 2.5 部署與版本獨立" title="Direct link to 2.5 部署與版本獨立" translate="no">​</a></h3>
<p>未來可實現：</p>
<ul>
<li>前台與後台採用不同的發版節奏</li>
<li>僅更新後台功能時，不動到前台 bundle</li>
<li>甚至可分別部署到不同 domain 或子路徑</li>
</ul>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-拆分核心策略clone--carve">3. 拆分核心策略：Clone &amp; Carve<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#3-%E6%8B%86%E5%88%86%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5clone--carve" class="hash-link" aria-label="Direct link to 3. 拆分核心策略：Clone &amp; Carve" title="Direct link to 3. 拆分核心策略：Clone &amp; Carve" translate="no">​</a></h2>
<p>本次拆分採用「Clone &amp; Carve」策略：</p>
<blockquote>
<p>先完整複製，再在複製版本中慢慢「削減」成新形狀，而不是直接改原本的 App。</p>
</blockquote>
<p>流程概念：</p>
<ol>
<li>先複製現有 App → 得到兩份一模一樣的應用</li>
<li>確保兩個 App 都能正常 serve / build</li>
<li>在新 App 中逐步刪除不需要的功能頁面</li>
<li>建立路由／部署分流</li>
<li>拆完後，再逐步抽出共用的 libs</li>
</ol>
<p>好處：</p>
<ul>
<li>原本的 <code>shopping-app</code> 在拆分初期完全不被動到</li>
<li>出現問題可以隨時回退到舊的單一 App</li>
<li>每個步驟都可以單獨測試與驗證</li>
</ul>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-視覺化流程與目錄結構">4. 視覺化流程與目錄結構<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#4-%E8%A6%96%E8%A6%BA%E5%8C%96%E6%B5%81%E7%A8%8B%E8%88%87%E7%9B%AE%E9%8C%84%E7%B5%90%E6%A7%8B" class="hash-link" aria-label="Direct link to 4. 視覺化流程與目錄結構" title="Direct link to 4. 視覺化流程與目錄結構" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-流程圖文字版">4.1 流程圖（文字版）<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#41-%E6%B5%81%E7%A8%8B%E5%9C%96%E6%96%87%E5%AD%97%E7%89%88" class="hash-link" aria-label="Direct link to 4.1 流程圖（文字版）" title="Direct link to 4.1 流程圖（文字版）" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[現有 shopping-app]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[複製為 backoffice-app]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[確認兩者可獨立 serve &amp; build]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[在 backoffice-app 內刪除前台頁面]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[建立兩者 routing / 部署分流]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[未來再抽出 shared libs]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[Build / 部署 / 權限 全面分離]</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="42-目錄結構變更">4.2 目錄結構變更<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#42-%E7%9B%AE%E9%8C%84%E7%B5%90%E6%A7%8B%E8%AE%8A%E6%9B%B4" class="hash-link" aria-label="Direct link to 4.2 目錄結構變更" title="Direct link to 4.2 目錄結構變更" translate="no">​</a></h3>
<p>拆分前：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apps/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  shopping-app/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pages/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      home</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      note</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      article</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      tag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      search</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      backoffice</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      admin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      transcript</span><br></span></code></pre></div></div>
<p>拆分後：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apps/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  shopping-app/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pages/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      home</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      note</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      article</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      tag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      search</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  backoffice-app/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pages/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      backoffice</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      admin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      transcript</span><br></span></code></pre></div></div>
<p>未來再視需求抽出 libs：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">libs/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  shared-model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  shared-api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  shared-domain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  shared-ui</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  shared-utils</span><br></span></code></pre></div></div>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-實作步驟操作手冊">5. 實作步驟（操作手冊）<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#5-%E5%AF%A6%E4%BD%9C%E6%AD%A5%E9%A9%9F%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8A" class="hash-link" aria-label="Direct link to 5. 實作步驟（操作手冊）" title="Direct link to 5. 實作步驟（操作手冊）" translate="no">​</a></h2>
<p>以下步驟以 Nx + Angular 為例，重點在「最小異動」與「可隨時回退」。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="51-複製現有-app">5.1 複製現有 App<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#51-%E8%A4%87%E8%A3%BD%E7%8F%BE%E6%9C%89-app" class="hash-link" aria-label="Direct link to 5.1 複製現有 App" title="Direct link to 5.1 複製現有 App" translate="no">​</a></h3>
<ol>
<li>
<p>在 repo 根目錄複製：</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cp -R apps/shopping-app apps/backoffice-app</span><br></span></code></pre></div></div>
</li>
<li>
<p>確認複製後目錄存在：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apps/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  shopping-app/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  backoffice-app/</span><br></span></code></pre></div></div>
</li>
</ol>
<p>此時兩個 App 的內容完全相同。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="511-nginx-proxy-導流測試在拆分前先做">5.1.1 Nginx Proxy 導流測試（在拆分前先做）<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#511-nginx-proxy-%E5%B0%8E%E6%B5%81%E6%B8%AC%E8%A9%A6%E5%9C%A8%E6%8B%86%E5%88%86%E5%89%8D%E5%85%88%E5%81%9A" class="hash-link" aria-label="Direct link to 5.1.1 Nginx Proxy 導流測試（在拆分前先做）" title="Direct link to 5.1.1 Nginx Proxy 導流測試（在拆分前先做）" translate="no">​</a></h3>
<div class="language-nginx codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-nginx codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 80;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  server_name yourdomain.com;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # 前台路由</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location / {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_pass http://localhost:4200;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # 後台路由</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /backoffice/ {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_pass http://localhost:4300;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # 避免 Angular 路由錯誤</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /backoffice {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 301 /backoffice/;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>說明：</p>
<ul>
<li>在拆 App 之前，就先建立 nginx proxy 路由</li>
<li>nginx 充當反向代理，幫助我們先驗證 path 分流</li>
<li>然後再複製 app 並建立 <code>backoffice-app</code></li>
</ul>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[加上 nginx proxy → 建立 / 與 /backoffice 路由分流]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[確認分流可正常把流量導向不同開發 port]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[複製 shopping-app → backoffice-app]</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="52-調整-backoffice-專案設定">5.2 調整 backoffice 專案設定<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#52-%E8%AA%BF%E6%95%B4-backoffice-%E5%B0%88%E6%A1%88%E8%A8%AD%E5%AE%9A" class="hash-link" aria-label="Direct link to 5.2 調整 backoffice 專案設定" title="Direct link to 5.2 調整 backoffice 專案設定" translate="no">​</a></h3>
<p>在 <code>backoffice-app</code> 底下，調整下列檔案：</p>
<ol>
<li>
<p><code>project.json</code></p>
<ul>
<li>將 name 由 <code>shopping-app</code> 調整為 <code>backoffice-app</code></li>
<li>確定 <code>sourceRoot</code> 指向 <code>apps/backoffice-app/src</code></li>
</ul>
</li>
<li>
<p><code>tsconfig.app.json</code></p>
<ul>
<li>確認 <code>extends</code>、<code>files</code>、<code>include</code> 等路徑指向 backoffice-app</li>
</ul>
</li>
<li>
<p><code>index.html</code></p>
<ul>
<li>修改 <code>&lt;title&gt;</code> 例如：<code>Backoffice Admin</code></li>
</ul>
</li>
</ol>
<p>調整完成後，在本機執行：</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nx serve shopping-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nx serve backoffice-app</span><br></span></code></pre></div></div>
<p>確認兩個 App 都能啟動且畫面正常，即可進入下一步。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="53-在-backoffice-app-中刪除前台頁面">5.3 在 backoffice-app 中刪除前台頁面<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#53-%E5%9C%A8-backoffice-app-%E4%B8%AD%E5%88%AA%E9%99%A4%E5%89%8D%E5%8F%B0%E9%A0%81%E9%9D%A2" class="hash-link" aria-label="Direct link to 5.3 在 backoffice-app 中刪除前台頁面" title="Direct link to 5.3 在 backoffice-app 中刪除前台頁面" translate="no">​</a></h3>
<p>目標：在不影響 <code>shopping-app</code> 的前提下，慢慢把 <code>backoffice-app</code> 修剪成「只有後台功能」的應用。</p>
<p>做法：</p>
<ol>
<li>
<p>在 <code>backoffice-app</code> 中，先確定 routing 結構與檔案位置</p>
</li>
<li>
<p>針對明顯前台功能（例如：<code>home</code>, <code>note</code>, <code>article</code>, <code>tag</code>, <code>search</code>），依序：</p>
<ul>
<li>從 routing 設定中移除該 path</li>
<li>移除頁面元件檔案</li>
<li>移除對應的測試檔、style 等</li>
</ul>
</li>
<li>
<p>每移除一組路由／頁面，都進行一次：</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nx build backoffice-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nx serve backoffice-app</span><br></span></code></pre></div></div>
<p>確認：</p>
<ul>
<li>build 無錯誤</li>
<li>主要後台路徑（例如 <code>/backoffice</code>, <code>/admin</code>, <code>/transcript</code>）仍可正常運作</li>
</ul>
</li>
</ol>
<p>完成後，目錄大致會變成：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apps/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  backoffice-app/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pages/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      backoffice</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      admin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      transcript</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="54-建立路由與部署分流">5.4 建立路由與部署分流<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#54-%E5%BB%BA%E7%AB%8B%E8%B7%AF%E7%94%B1%E8%88%87%E9%83%A8%E7%BD%B2%E5%88%86%E6%B5%81" class="hash-link" aria-label="Direct link to 5.4 建立路由與部署分流" title="Direct link to 5.4 建立路由與部署分流" translate="no">​</a></h3>
<p>在 gateway / nginx / 前端部署設定中，將路由切開，例如：</p>
<ul>
<li><code>/</code> 或 <code>/app</code> → 指向 <code>shopping-app</code> build 出來的 bundle</li>
<li><code>/backoffice</code> 或 <code>/admin</code> → 指向 <code>backoffice-app</code> build 出來的 bundle</li>
</ul>
<p>如此一來：</p>
<ul>
<li>使用者造訪前台時，不會載入後台的程式碼</li>
<li>後台可以獨立演進、獨立測試</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="55-拆分完成後的共用程式抽離後期">5.5 拆分完成後的共用程式抽離（後期）<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#55-%E6%8B%86%E5%88%86%E5%AE%8C%E6%88%90%E5%BE%8C%E7%9A%84%E5%85%B1%E7%94%A8%E7%A8%8B%E5%BC%8F%E6%8A%BD%E9%9B%A2%E5%BE%8C%E6%9C%9F" class="hash-link" aria-label="Direct link to 5.5 拆分完成後的共用程式抽離（後期）" title="Direct link to 5.5 拆分完成後的共用程式抽離（後期）" translate="no">​</a></h3>
<p>拆分前期不建議直接抽 libs，以免一次改動太大。</p>
<p>當兩個 App 穩定運作後，可以開始評估：</p>
<ul>
<li>共用的 model / DTO</li>
<li>共用的 API service</li>
<li>共用的 UI components</li>
<li>共用的 util / helper</li>
</ul>
<p>再逐步抽到 <code>libs/</code> 底下的 shared 專案中，搭配 Nx 提供的 dependency graph 逐步優化結構。</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-測試與風險控管">6. 測試與風險控管<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#6-%E6%B8%AC%E8%A9%A6%E8%88%87%E9%A2%A8%E9%9A%AA%E6%8E%A7%E7%AE%A1" class="hash-link" aria-label="Direct link to 6. 測試與風險控管" title="Direct link to 6. 測試與風險控管" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="61-建議的測試順序">6.1 建議的測試順序<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#61-%E5%BB%BA%E8%AD%B0%E7%9A%84%E6%B8%AC%E8%A9%A6%E9%A0%86%E5%BA%8F" class="hash-link" aria-label="Direct link to 6.1 建議的測試順序" title="Direct link to 6.1 建議的測試順序" translate="no">​</a></h3>
<p>每一個拆分步驟都建議至少做：</p>
<ol>
<li>單一 App build 測試：<!-- -->
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nx build shopping-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nx build backoffice-app</span><br></span></code></pre></div></div>
</li>
<li>本地手動驗證關鍵路由：<!-- -->
<ul>
<li>前台：主要使用者流程是否正常</li>
<li>後台：登入、查詢、管理功能是否正常</li>
</ul>
</li>
<li>重要節點時執行 e2e / smoke test</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="62-風險與對應策略">6.2 風險與對應策略<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#62-%E9%A2%A8%E9%9A%AA%E8%88%87%E5%B0%8D%E6%87%89%E7%AD%96%E7%95%A5" class="hash-link" aria-label="Direct link to 6.2 風險與對應策略" title="Direct link to 6.2 風險與對應策略" translate="no">​</a></h3>
<table><thead><tr><th>風險類型</th><th>說明</th><th>對應策略</th></tr></thead><tbody><tr><td>build 爆炸</td><td>一次改太多檔案</td><td>每次只做小步驟，改完就 build 一次</td></tr><tr><td>路由錯亂</td><td>path 指到錯的 App</td><td>將前後台 routing 寫在文件與設定中統一管理</td></tr><tr><td>共用程式被誤刪</td><td>後台仍需要前台某段邏輯</td><td>初期只刪除「明顯純 UI」頁面，不動 domain / service</td></tr><tr><td>難以回退</td><td>多步驟混在同一 commit</td><td>每個重要步驟分開 commit，必要時可 git revert</td></tr></tbody></table>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-結語">7. 結語<a href="https://rhincodon.studio/en/blog/nx-app-split-strategy#7-%E7%B5%90%E8%AA%9E" class="hash-link" aria-label="Direct link to 7. 結語" title="Direct link to 7. 結語" translate="no">​</a></h2>
<p>本次 Nx App 拆分的目標，不是追求一次到位的「完美架構」，而是：</p>
<ol>
<li>在不影響現有使用者的情況下，先把前後台在應用層分離開來</li>
<li>降低 build 時間與 bundle 大小，改善開發與使用體驗</li>
<li>為未來的 libs 抽離與獨立部署鋪路</li>
</ol>
<p>核心心法：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Keep it working → Keep it separated → Keep it evolving</span><br></span></code></pre></div></div>
<p>先讓系統穩定分家，再持續演進結構，是目前最務實、風險最低的拆分路線。</p>]]></content:encoded>
            <category>nx</category>
            <category>angular</category>
            <category>architecture</category>
            <category>monorepo</category>
        </item>
        <item>
            <title><![CDATA[n8n Course Level 1]]></title>
            <link>https://rhincodon.studio/en/blog/n8n-course-level1</link>
            <guid>https://rhincodon.studio/en/blog/n8n-course-level1</guid>
            <pubDate>Thu, 20 Nov 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[跟著人生攻略研究所所長，一步步完成 n8n Level 1 測驗的紀錄。]]></description>
            <content:encoded><![CDATA[<p>跟著人生攻略研究所所長的腳步，正式踏進 n8n Course Level 1 的測驗流程。<br>
<!-- -->整體難度不算高，但實際作答時，還是有幾題需要重新確認邏輯與分類方式。</p>
<p>事前準備按著所長的教學完成註冊與金鑰取得：<br>
<a href="https://lifecheatslab.com/n8n-course/#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%A8%BB%E5%86%8A_Level_1_%E6%B8%AC%E9%A9%97%EF%BC%8C%E5%8F%96%E5%BE%97%E5%80%8B%E4%BA%BA%E9%87%91%E9%91%B0" target="_blank" rel="noopener noreferrer">https://lifecheatslab.com/n8n-course/#第一步：註冊_Level_1_測驗，取得個人金鑰</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="理論題">理論題<a href="https://rhincodon.studio/en/blog/n8n-course-level1#%E7%90%86%E8%AB%96%E9%A1%8C" class="hash-link" aria-label="Direct link to 理論題" title="Direct link to 理論題" translate="no">​</a></h3>
<p>在整份題庫裡，理論題的第 4 題與第 6 題特別容易讓人猶豫。</p>
<ul>
<li>
<p><strong>第 4 題</strong>：What can you do if there is no n8n node for an app/service that you want to use in a workflow?</p>
</li>
<li>
<p><strong>第 6 題</strong>：Which of the following are Trigger Nodes?<br>
<!-- -->依題目列出的選項來看，除了 Schedule node；Airtable node 實作上也可以。</p>
</li>
</ul>
<p>其他題目主要檢查對 n8n 基礎概念的掌握：哪些節點能啟動 workflow、Code node 必須回傳什麼格式、資料結構怎麼判讀等等。<br>
<!-- -->多利用官方文件與搜尋，大部分都能順利作答。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="實作題">實作題<a href="https://rhincodon.studio/en/blog/n8n-course-level1#%E5%AF%A6%E4%BD%9C%E9%A1%8C" class="hash-link" aria-label="Direct link to 實作題" title="Direct link to 實作題" translate="no">​</a></h3>
<p>實作題的部分只要掌握流程邏輯，其實不算太複雜。<br>
<!-- -->最方便的方式，是先匯入官方提供的完成版 workflow，再依照題目逐步調整即可。</p>
<p>官方 workflow JSON：<br>
<a href="https://docs.n8n.io/_workflows/courses/level-one/finished.json" target="_blank" rel="noopener noreferrer">https://docs.n8n.io/_workflows/courses/level-one/finished.json</a></p>
<p>匯入後，照題目要求調整各個節點：補上 IF 條件、調整資料格式、確認流程順序。<br>
<!-- -->Airtable 在這份測驗裡不需要真的去操作，直接略過就好，不會影響作答結果。<br>
<!-- -->整體流程清楚、節點之間的連動也好檢查，照著步驟實作很快就能完成。</p>
<p>搭配課程文件的補充說明：<br>
<a href="https://docs.n8n.io/courses/level-one/chapter-7/" target="_blank" rel="noopener noreferrer">https://docs.n8n.io/courses/level-one/chapter-7/</a></p>
<p>雖然只是 Level 1，但完成後看到進度亮起來，還是有種踏出第一步的成就感。</p>
<p><img decoding="async" loading="lazy" alt="n8n-course-level1.png" src="https://rhincodon.studio/en/assets/images/n8n-course-level1-c0cd91486111556753cc4d4c4626e4be.png" width="986" height="633" class="img_ev3q"></p>]]></content:encoded>
            <category>n8n-course-level1</category>
        </item>
        <item>
            <title><![CDATA[Why the World Calls Him “Da Vinci”]]></title>
            <link>https://rhincodon.studio/en/blog/leonardo-da-vinci-name</link>
            <guid>https://rhincodon.studio/en/blog/leonardo-da-vinci-name</guid>
            <pubDate>Sun, 12 Oct 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[Exploring why the world calls Leonardo “Da Vinci,” when it really just means “from Vinci.”]]></description>
            <content:encoded><![CDATA[<blockquote>
<p><em>“Leonardo di ser Piero da Vinci” — Leonardo, son of Piero from Vinci.</em></p>
</blockquote>
<p>Today I came across something interesting about <strong>Leonardo da Vinci</strong>, the legendary polymath who lived during the Renaissance.<br>
<!-- -->He was <strong>born on April 15, 1452</strong>, and <strong>died on 2 May 1519</strong>.</p>
<p>His full name was <strong>Leonardo di ser Piero da Vinci</strong>, which literally means:</p>
<blockquote>
<p><strong>Leonardo, son of Piero from Vinci</strong></p>
</blockquote>
<p>The phrase <strong>“da Vinci”</strong> simply means <em>“from Vinci”</em>, referring to a small town near Florence in the <strong>Republic of Florence (Repubblica Fiorentina)</strong>.</p>
<p>What’s fascinating is that the entire world now calls him <strong>“Da Vinci”</strong>,<br>
<!-- -->as if “Vinci” were his family name — but in reality, it’s just where he was born.</p>
<p>Imagine if a brilliant person were born in Taipei,<br>
<!-- -->and the whole world started calling them <strong>“Taipei”</strong> instead of their real name.<br>
<!-- -->That’s essentially what happened with Leonardo da Vinci.</p>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="小結">小結<a href="https://rhincodon.studio/en/blog/leonardo-da-vinci-name#%E5%B0%8F%E7%B5%90" class="hash-link" aria-label="Direct link to 小結" title="Direct link to 小結" translate="no">​</a></h3>
<p>李奧納多的名字其實代表了他的出身：</p>
<blockquote>
<p><strong>Leonardo di ser Piero da Vinci = 李奧納多，皮耶羅之子，來自文西城。</strong></p>
</blockquote>
<p>但世人卻以他的出生地「文西」來稱呼他。<br>
<!-- -->這樣的現象不僅反映語言習慣，也讓我們看到歷史如何在傳播中重新塑造一個人的名字與身份。</p>]]></content:encoded>
            <category>history</category>
            <category>art</category>
            <category>language</category>
            <category>leonardo-da-vinci</category>
        </item>
    </channel>
</rss>